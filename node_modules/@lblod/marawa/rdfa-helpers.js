'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isRelativeUrl = exports.isFullUri = exports.rdfaAttributesToTriples = exports.resolvePrefix = exports.enrichWithRdfaProperties = undefined;

var _rdfaConfig = require('./support/rdfa-config');

var _rdfaAttributes = require('./rdfa-attributes');

var _rdfaAttributes2 = _interopRequireDefault(_rdfaAttributes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
                                                                                                                                                                                                     * Helpers to process RDFa on DOM nodes
                                                                                                                                                                                                     */


/**
 * Enriches a rich node with semantic properties:
 * - rdfaPrefixes: map of prefixes at the current node
 * - rdfaAttributes: resolved (non-prefixed) RDFa attributes set on the node
 * - rdfaContext: array of rdfaAttributes from the top to the current node
 *
 * @method enrichWithRdfaProperties
 *
 * @param {RichNode} richNode Rich node to expand the RDFa from
 * @param {Array} parentContext RDFa context (array of rdfaAttributes) of the node's parent
 * @param {Object} parentPrefixes RDFa prefixes defined at the node's parent level
 */
function enrichWithRdfaProperties(richNode) {
  var parentContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var parentPrefixes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _rdfaConfig.defaultPrefixes;

  var rdfaAttributes = new _rdfaAttributes2.default(richNode.domNode, parentPrefixes);

  if (!rdfaAttributes.isEmpty) {
    richNode.rdfaPrefixes = rdfaAttributes.currentPrefixes;
    richNode.rdfaAttributes = rdfaAttributes;
    richNode.rdfaContext = [].concat(_toConsumableArray(parentContext), [rdfaAttributes]);
  } else {
    richNode.rdfaPrefixes = parentPrefixes;
    richNode.rdfaAttributes = null;
    richNode.rdfaContext = parentContext;
  }
}

/**
 * Resolves a given (array of) URI(s) with the correct prefix (if it's prefixed)
 * based on a set of known prefixes.
 *
 * @method resolvePrefix
 *
 * @param {string|Array} uri An (array of) URI(s) to resolve
 * @param {Object} prefixes A map of known prefixes
 *
 * @return {string} The resolved URI
 */
function resolvePrefix(uri, prefixes) {
  var resolve = function resolve(uri) {
    if (isFullUri(uri) || isRelativeUrl(uri)) {
      return uri;
    } else {
      var i = uri.indexOf(':');

      if (i < 0) {
        // no prefix defined. Use default.
        if (prefixes[''] == null) console.warn('No default RDFa prefix defined', { id: 'rdfa-helpers.missingPrefix' });
        uri = prefixes[''] + uri;
      } else {
        var key = uri.substr(0, i);
        if (prefixes[key] == null) console.warn('No RDFa prefix \'' + key + '\' defined', { id: 'rdfa-helpers.missingPrefix' });
        uri = prefixes[key] + uri.substr(i + 1);
      }

      return uri;
    }
  };

  if (Array.isArray(uri)) {
    return uri.map(function (u) {
      return resolve(u);
    });
  } else {
    return resolve(uri);
  }
}

/**
 * Transforms an array of RDFa attribute objects to an array of triples.
 * A triple is an object consisting of a subject, predicate and object.
 * Optionally, a triple can contain a datatype.
 * In case object is an IRI, datatype is set to rdfs:Resource.
 * In case object is a literal, dataype is set to the RDFa attributes datatype
 * and null if no datatype is set in the RDFa attributes.
 *
 * @method rdfaAttributesToTriples
 *
 * @param {Array} rdfaAttributes An array of RDFa attribute objects
 *
 * @returns {Array} An array of triple objects
 */
function rdfaAttributesToTriples(rdfaAttributes) {
  var graph = [];

  var currentScope = null;

  // the object of a triple generated by the usage of 'rel'/'rev' may be on a deeper level
  // hence we need to keep track of the outstanding rel-triples across iterations
  var outstandingRelTriples = [];

  rdfaAttributes.forEach(function (rdfa) {
    var nextScope = null; // subject of the next iteration


    // Determine predicates

    var propertyTriples = (rdfa['properties'] || []).map(function (property) {
      return { predicate: property };
    });
    var relTriples = (rdfa['rel'] || []).map(function (rel) {
      return { predicate: rel };
    });
    var revTriples = (rdfa['rev'] || []).map(function (rev) {
      return { predicate: '^' + rev };
    });
    relTriples = [].concat(_toConsumableArray(relTriples), _toConsumableArray(revTriples));

    // Determine subject

    if (rdfa['about'] != null) {
      currentScope = rdfa['about'];
      if (outstandingRelTriples.length) {
        var rel = outstandingRelTriples[0].predicate;
        console.warn('Subject changes to ' + currentScope + '. No object found for predicate ' + rel + ' set via \'rel/rev\'. These incomplete triples will be discarded.');
        outstandingRelTriples = [];
      }
    }
    if (!propertyTriples.length && !relTriples.length) {
      if (rdfa['resource'] != null) {
        // resource is set without property/rel/rev
        currentScope = rdfa['resource'];
      }
    } else {
      if (rdfa['resource'] != null) {
        nextScope = rdfa['resource'];
      }
    }

    [].concat(_toConsumableArray(propertyTriples), _toConsumableArray(relTriples)).forEach(function (triple) {
      return triple.subject = currentScope;
    });

    // Determine object and datatype

    propertyTriples.forEach(function (triple) {
      triple.object = rdfa['content'] || rdfa['resource'] || rdfa['href'] || rdfa['src'] || rdfa['text'];
      if (rdfa['resource'] || rdfa['href'] || rdfa['src']) triple.datatype = 'http://www.w3.org/2000/01/rdf-schema#Resource';else triple.datatype = rdfa['datatype'];
    });

    graph = [].concat(_toConsumableArray(graph), _toConsumableArray(propertyTriples));

    outstandingRelTriples = [].concat(_toConsumableArray(outstandingRelTriples), _toConsumableArray(relTriples));
    var object = rdfa['resource'] || rdfa['href'] || rdfa['src']; // rel/rev never considers the textual content of an element as object
    if (object) {
      outstandingRelTriples.forEach(function (triple) {
        triple.object = object;
        triple.datatype = 'http://www.w3.org/2000/01/rdf-schema#Resource';
      });
      graph = [].concat(_toConsumableArray(graph), _toConsumableArray(outstandingRelTriples));
      outstandingRelTriples = [];
    };

    // Typeof triples

    var typeofTriples = [];
    if (rdfa['typeof'] != null) {
      typeofTriples = rdfa['typeof'].map(function (type) {
        return {
          // we assume typeof only applies on resource/about of current node. Not of a parent node.
          subject: rdfa['resource'] || rdfa['about'], // create a blank node if subject == null
          predicate: 'a',
          object: type,
          datatype: 'http://www.w3.org/2000/01/rdf-schema#Resource'
        };
      });
    }

    graph = [].concat(_toConsumableArray(graph), _toConsumableArray(typeofTriples));

    // Next iteration bookkeeping

    if (nextScope != null) {
      currentScope = nextScope;
    }
  });

  // reverse inverse triples
  graph = graph.map(function (triple) {
    if (triple.predicate.startsWith('^')) {
      return {
        subject: triple.object,
        predicate: triple.predicate.slice(1),
        object: triple.subject
      };
    } else {
      return triple;
    }
  });

  return graph;
}

/**
 * Returns whether a given URI is a full URI.
 *
 * @method isFullUri
 *
 * @param {string} uri A URI
 *
 * @return {boolean} Whether the given URI is a full URI.
 */
function isFullUri(uri) {
  return uri.includes('://');
}

/**
 * Returns whether a given URI is a relative URI.
 *
 * @method isRelativeUrl
 *
 * @param {string} uri A URI
 *
 * @return {boolean} Whether the given URI is a relative URI.
 */
function isRelativeUrl(uri) {
  return uri.startsWith('#') || uri.startsWith('/') || uri.startsWith('./') || uri.startsWith('../');
}

exports.enrichWithRdfaProperties = enrichWithRdfaProperties;
exports.resolvePrefix = resolvePrefix;
exports.rdfaAttributesToTriples = rdfaAttributesToTriples;
exports.isFullUri = isFullUri;
exports.isRelativeUrl = isRelativeUrl;