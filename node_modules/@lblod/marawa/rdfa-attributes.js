'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePrefixString = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _rdfaConfig = require('./support/rdfa-config');

var _rdfaHelpers = require('./rdfa-helpers');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Represents the RDFa attributes set on a node
 *
 * Note: The attributes of an existing RdfaAttributes object should not be updated.
 * A new RdfaAttributes object should be created in that case.
 *
 * TODO: add support for language
 *
 * @class RdfaAttributes
 * @constructor
*/
var RdfaAttributes = function () {
  function RdfaAttributes(domNode) {
    var knownPrefixes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _rdfaConfig.defaultPrefixes;

    _classCallCheck(this, RdfaAttributes);

    if (domNode && domNode.getAttribute) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _rdfaConfig.rdfaKeywords[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          this['_' + key] = domNode.getAttribute(key);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      ;
      this.text = domNode.textContent;
      this.setResolvedAttributes(knownPrefixes);
    }
  }

  _createClass(RdfaAttributes, [{
    key: 'setResolvedAttributes',


    /**
     * @method setResolvedAttributes
     * @private
     *
     * The RdfaAttributes object stores the RDFa attributes in several formats:
     * _attribute (e.g. _property): the raw value as set on the node. Null if not set.
     * _attributes (e.g. _properties): an array of values for attributes that are multivalued. Null if not set.
     * attribute (e.g. properties): (array of) values with resolved prefixes
    */
    value: function setResolvedAttributes(knownPrefixes) {
      this.currentPrefixes = Object.assign({}, knownPrefixes);
      this.splitMultivalueAttributes();
      this.updateCurrentPrefixes();
      this.resolvePrefixedAttributes();
    }

    /**
     * @method splitMultivalueAttributes
     * @private
    */

  }, {
    key: 'splitMultivalueAttributes',
    value: function splitMultivalueAttributes() {
      var keywords = {
        property: 'properties',
        typeof: 'typeof',
        rel: 'rel',
        rev: 'rev'
      };

      for (var key in keywords) {
        var listKey = '_' + keywords[key];
        var value = this['_' + key];
        if (value != null) {
          this[listKey] = value.split(' '); // TODO support splitting on multiple spaces
        } else {
          this[listKey] = null;
        }
      }

      if (this._prefix != null) {
        this.prefixes = parsePrefixString(this._prefix);
      } else {
        this.prefixes = null;
      }
    }

    /**
     * @private
     * @method updateCurrentPrefixes
     */

  }, {
    key: 'updateCurrentPrefixes',
    value: function updateCurrentPrefixes() {
      if (this.vocab != null) {
        this.currentPrefixes[''] = this.vocab;
      }
      if (this.prefixes != null) {
        for (var key in this.prefixes) {
          this.currentPrefixes[key] = this.prefixes[key];
        }
      }
    }

    /**
     * @private
     * @method resolvePrefixedAttributes
     */

  }, {
    key: 'resolvePrefixedAttributes',
    value: function resolvePrefixedAttributes() {
      var _this = this;

      var prefixableRdfaKeywords = ['typeof', 'properties', 'rel', 'rev', 'src', 'href', 'resource', 'about', 'datatype'];

      prefixableRdfaKeywords.forEach(function (key) {
        if (_this['_' + key] != null) _this[key] = (0, _rdfaHelpers.resolvePrefix)(_this['_' + key], _this.currentPrefixes);
      });
    }
  }, {
    key: 'vocab',
    get: function get() {
      return this._vocab;
    }
  }, {
    key: 'content',
    get: function get() {
      return this._content;
    }
  }, {
    key: 'property',
    get: function get() {
      console.warn('[DEPRECATED] Property \'property\' of RdfaAttributes is deprecated. Please use \'properties\' instead.');
      return this.properties && this.properties.length && this.properties[0];
    }

    /**
     * Returns whether an RDFa attribute is set
     */

  }, {
    key: 'isEmpty',
    get: function get() {
      var _this2 = this;

      return _rdfaConfig.rdfaKeywords.find(function (key) {
        return _this2['_' + key] != null;
      }) == null;
    }
  }]);

  return RdfaAttributes;
}();

/**
 * Parses an RDFa prefix string and returns a map of prefixes to URIs.
 * According to the RDFa spec prefixes must be seperated by exactly one space.
 *
 * @method parsePrefixString
 * @param string prefixString Space-seperated string of RDFa prefixes
 * @return Object Map of prefixes to their URI
*/


var parsePrefixString = function parsePrefixString(prefixString) {
  var parts = prefixString.split(' ');
  var prefixes = {};
  // parts is an array like ['mu:', 'http://mu.semte.ch...', 'ext:', 'http://...', ...]
  // transform to an object like { mu: 'http://mu.semte.ch...', ext: 'http://...', ... }
  for (var i = 0; i < parts.length; i = i + 2) {
    var key = parts[i].substr(0, parts[i].length - 1);
    prefixes[key] = parts[i + 1];
  }

  return prefixes;
};

exports.default = RdfaAttributes;
exports.parsePrefixString = parsePrefixString;